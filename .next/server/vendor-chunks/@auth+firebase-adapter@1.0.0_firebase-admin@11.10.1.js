"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@auth+firebase-adapter@1.0.0_firebase-admin@11.10.1";
exports.ids = ["vendor-chunks/@auth+firebase-adapter@1.0.0_firebase-admin@11.10.1"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@auth+firebase-adapter@1.0.0_firebase-admin@11.10.1/node_modules/@auth/firebase-adapter/index.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@auth+firebase-adapter@1.0.0_firebase-admin@11.10.1/node_modules/@auth/firebase-adapter/index.js ***!
  \*****************************************************************************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirestoreAdapter: () => (/* binding */ FirestoreAdapter),\n/* harmony export */   collectionsFactory: () => (/* binding */ collectionsFactory),\n/* harmony export */   getDoc: () => (/* binding */ getDoc),\n/* harmony export */   getOneDoc: () => (/* binding */ getOneDoc),\n/* harmony export */   initFirestore: () => (/* binding */ initFirestore),\n/* harmony export */   mapFieldsFactory: () => (/* binding */ mapFieldsFactory)\n/* harmony export */ });\n/* harmony import */ var firebase_admin_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase-admin/app */ \"firebase-admin/app\");\n/* harmony import */ var firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase-admin/firestore */ \"firebase-admin/firestore\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([firebase_admin_app__WEBPACK_IMPORTED_MODULE_0__, firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__]);\n([firebase_admin_app__WEBPACK_IMPORTED_MODULE_0__, firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n/**\n * <div style={{display: \"flex\", justifyContent: \"space-between\", alignItems: \"center\", padding: 16}}>\n * <span>\n *  Official <b>Firebase</b> adapter for Auth.js / NextAuth.js,\n *  using the <a href=\"https://firebase.google.com/docs/admin/setup\">Firebase Admin SDK</a>\n *  &nbsp;and <a href=\"https://firebase.google.com/docs/firestore\">Firestore</a>.</span>\n * <a href=\"https://firebase.google.com/\">\n *   <img style={{display: \"block\"}} src=\"https://authjs.dev/img/adapters/firebase.svg\" height=\"48\" width=\"48\"/>\n * </a>\n * </div>\n *\n * ## Installation\n *\n * ```bash npm2yarn2pnpm\n * npm install @auth/firebase-adapter firebase-admin\n * ```\n *\n * @module @auth/firebase-adapter\n */ \n\n/**\n * ## Setup\n *\n * First, create a Firebase project and generate a service account key. Visit: `https://console.firebase.google.com/u/0/project/{project-id}/settings/serviceaccounts/adminsdk` (replace `{project-id}` with your project's id)\n *\n * Now you have a few options to authenticate with the Firebase Admin SDK in your app:\n *\n * ### Environment variables\n *  - Download the service account key and save it in your project. (Make sure to add the file to your `.gitignore`!)\n *  - Add [`GOOGLE_APPLICATION_CREDENTIALS`](https://cloud.google.com/docs/authentication/application-default-credentials#GAC) to your environment variables and point it to the service account key file.\n *  - The adapter will automatically pick up the environment variable and use it to authenticate with the Firebase Admin SDK.\n *\n * @example\n * ```ts title=\"pages/api/auth/[...nextauth].ts\"\n * import NextAuth from \"next-auth\"\n * import { FirestoreAdapter } from \"@auth/firebase-adapter\"\n *\n * export default NextAuth({\n *   adapter: FirestoreAdapter(),\n *   // ...\n * })\n * ```\n *\n * ### Service account values\n *\n * - Download the service account key to a temporary location. (Make sure to not commit this file to your repository!)\n * - Add the following environment variables to your project: `FIREBASE_PROJECT_ID`, `FIREBASE_CLIENT_EMAIL`, `FIREBASE_PRIVATE_KEY`.\n * - Pass the config to the adapter, using the environment variables as shown in the example below.\n *\n * @example\n * ```ts title=\"pages/api/auth/[...nextauth].ts\"\n * import NextAuth from \"next-auth\"\n * import { FirestoreAdapter } from \"@auth/firebase-adapter\"\n * import { cert } from \"firebase-admin/app\"\n *\n * export default NextAuth({\n *  adapter: FirestoreAdapter({\n *    credential: cert({\n *      projectId: process.env.FIREBASE_PROJECT_ID,\n *      clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n *      privateKey: process.env.FIREBASE_PRIVATE_KEY,\n *    })\n *  })\n *  // ...\n * })\n * ```\n *\n * ### Using an existing Firestore instance\n *\n * If you already have a Firestore instance, you can pass that to the adapter directly instead.\n *\n * :::note\n * When passing an instance and in a serverless environment, remember to handle duplicate app initialization.\n * :::\n *\n * :::tip\n * You can use the {@link initFirestore} utility to initialize the app and get an instance safely.\n * :::\n *\n * @example\n * ```ts title=\"pages/api/auth/[...nextauth].ts\"\n * import NextAuth from \"next-auth\"\n * import { FirestoreAdapter } from \"@auth/firebase-adapter\"\n * import { firestore } from \"lib/firestore\"\n *\n * export default NextAuth({\n *  adapter: FirestoreAdapter(firestore),\n *  // ...\n * })\n * ```\n */ function FirestoreAdapter(config) {\n    const { db, namingStrategy = \"default\" } = config instanceof firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__.Firestore ? {\n        db: config\n    } : {\n        ...config,\n        db: config?.firestore ?? initFirestore(config)\n    };\n    const preferSnakeCase = namingStrategy === \"snake_case\";\n    const C = collectionsFactory(db, preferSnakeCase);\n    const mapper = mapFieldsFactory(preferSnakeCase);\n    return {\n        async createUser (userInit) {\n            const { id: userId } = await C.users.add(userInit);\n            const user = await getDoc(C.users.doc(userId));\n            if (!user) throw new Error(\"[createUser] Failed to fetch created user\");\n            return user;\n        },\n        async getUser (id) {\n            return await getDoc(C.users.doc(id));\n        },\n        async getUserByEmail (email) {\n            return await getOneDoc(C.users.where(\"email\", \"==\", email));\n        },\n        async getUserByAccount ({ provider, providerAccountId }) {\n            const account = await getOneDoc(C.accounts.where(\"provider\", \"==\", provider).where(mapper.toDb(\"providerAccountId\"), \"==\", providerAccountId));\n            if (!account) return null;\n            return await getDoc(C.users.doc(account.userId));\n        },\n        async updateUser (partialUser) {\n            if (!partialUser.id) throw new Error(\"[updateUser] Missing id\");\n            const userRef = C.users.doc(partialUser.id);\n            await userRef.set(partialUser, {\n                merge: true\n            });\n            const user = await getDoc(userRef);\n            if (!user) throw new Error(\"[updateUser] Failed to fetch updated user\");\n            return user;\n        },\n        async deleteUser (userId) {\n            await db.runTransaction(async (transaction)=>{\n                const accounts = await C.accounts.where(mapper.toDb(\"userId\"), \"==\", userId).get();\n                const sessions = await C.sessions.where(mapper.toDb(\"userId\"), \"==\", userId).get();\n                transaction.delete(C.users.doc(userId));\n                accounts.forEach((account)=>transaction.delete(account.ref));\n                sessions.forEach((session)=>transaction.delete(session.ref));\n            });\n        },\n        async linkAccount (accountInit) {\n            const ref = await C.accounts.add(accountInit);\n            const account = await ref.get().then((doc)=>doc.data());\n            return account ?? null;\n        },\n        async unlinkAccount ({ provider, providerAccountId }) {\n            await deleteDocs(C.accounts.where(\"provider\", \"==\", provider).where(mapper.toDb(\"providerAccountId\"), \"==\", providerAccountId).limit(1));\n        },\n        async createSession (sessionInit) {\n            const ref = await C.sessions.add(sessionInit);\n            const session = await ref.get().then((doc)=>doc.data());\n            if (session) return session ?? null;\n            throw new Error(\"[createSession] Failed to fetch created session\");\n        },\n        async getSessionAndUser (sessionToken) {\n            const session = await getOneDoc(C.sessions.where(mapper.toDb(\"sessionToken\"), \"==\", sessionToken));\n            if (!session) return null;\n            const user = await getDoc(C.users.doc(session.userId));\n            if (!user) return null;\n            return {\n                session,\n                user\n            };\n        },\n        async updateSession (partialSession) {\n            const sessionId = await db.runTransaction(async (transaction)=>{\n                const sessionSnapshot = (await transaction.get(C.sessions.where(mapper.toDb(\"sessionToken\"), \"==\", partialSession.sessionToken).limit(1))).docs[0];\n                if (!sessionSnapshot?.exists) return null;\n                transaction.set(sessionSnapshot.ref, partialSession, {\n                    merge: true\n                });\n                return sessionSnapshot.id;\n            });\n            if (!sessionId) return null;\n            const session = await getDoc(C.sessions.doc(sessionId));\n            if (session) return session;\n            throw new Error(\"[updateSession] Failed to fetch updated session\");\n        },\n        async deleteSession (sessionToken) {\n            await deleteDocs(C.sessions.where(mapper.toDb(\"sessionToken\"), \"==\", sessionToken).limit(1));\n        },\n        async createVerificationToken (verificationToken) {\n            await C.verification_tokens.add(verificationToken);\n            return verificationToken;\n        },\n        async useVerificationToken ({ identifier, token }) {\n            const verificationTokenSnapshot = (await C.verification_tokens.where(\"identifier\", \"==\", identifier).where(\"token\", \"==\", token).limit(1).get()).docs[0];\n            if (!verificationTokenSnapshot) return null;\n            const data = verificationTokenSnapshot.data();\n            await verificationTokenSnapshot.ref.delete();\n            return data;\n        }\n    };\n}\n// for consistency, store all fields as snake_case in the database\nconst MAP_TO_FIRESTORE = {\n    userId: \"user_id\",\n    sessionToken: \"session_token\",\n    providerAccountId: \"provider_account_id\",\n    emailVerified: \"email_verified\"\n};\nconst MAP_FROM_FIRESTORE = {};\nfor(const key in MAP_TO_FIRESTORE){\n    MAP_FROM_FIRESTORE[MAP_TO_FIRESTORE[key]] = key;\n}\nconst identity = (x)=>x;\n/** @internal */ function mapFieldsFactory(preferSnakeCase) {\n    if (preferSnakeCase) {\n        return {\n            toDb: (field)=>MAP_TO_FIRESTORE[field] ?? field,\n            fromDb: (field)=>MAP_FROM_FIRESTORE[field] ?? field\n        };\n    }\n    return {\n        toDb: identity,\n        fromDb: identity\n    };\n}\n/** @internal */ function getConverter(options) {\n    const mapper = mapFieldsFactory(options?.preferSnakeCase ?? false);\n    return {\n        toFirestore (object) {\n            const document = {};\n            for(const key in object){\n                if (key === \"id\") continue;\n                const value = object[key];\n                if (value !== undefined) {\n                    document[mapper.toDb(key)] = value;\n                } else {\n                    console.warn(`FirebaseAdapter: value for key \"${key}\" is undefined`);\n                }\n            }\n            return document;\n        },\n        fromFirestore (snapshot) {\n            const document = snapshot.data(); // we can guarantee it exists\n            const object = {};\n            if (!options?.excludeId) {\n                object.id = snapshot.id;\n            }\n            for(const key in document){\n                let value = document[key];\n                if (value instanceof firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp) value = value.toDate();\n                object[mapper.fromDb(key)] = value;\n            }\n            return object;\n        }\n    };\n}\n/** @internal */ async function getOneDoc(querySnapshot) {\n    const querySnap = await querySnapshot.limit(1).get();\n    return querySnap.docs[0]?.data() ?? null;\n}\n/** @internal */ async function deleteDocs(querySnapshot) {\n    const querySnap = await querySnapshot.get();\n    for (const doc of querySnap.docs){\n        await doc.ref.delete();\n    }\n}\n/** @internal */ async function getDoc(docRef) {\n    const docSnap = await docRef.get();\n    return docSnap.data() ?? null;\n}\n/** @internal */ function collectionsFactory(db, preferSnakeCase = false) {\n    return {\n        users: db.collection(\"users\").withConverter(getConverter({\n            preferSnakeCase\n        })),\n        sessions: db.collection(\"sessions\").withConverter(getConverter({\n            preferSnakeCase\n        })),\n        accounts: db.collection(\"accounts\").withConverter(getConverter({\n            preferSnakeCase\n        })),\n        verification_tokens: db.collection(preferSnakeCase ? \"verification_tokens\" : \"verificationTokens\").withConverter(getConverter({\n            preferSnakeCase,\n            excludeId: true\n        }))\n    };\n}\n/**\n * Utility function that helps making sure that there is no duplicate app initialization issues in serverless environments.\n * If no parameter is passed, it will use the `GOOGLE_APPLICATION_CREDENTIALS` environment variable to initialize a Firestore instance.\n *\n * @example\n * ```ts title=\"lib/firestore.ts\"\n * import { initFirestore } from \"@auth/firebase-adapter\"\n * import { cert } from \"firebase-admin/app\"\n *\n * export const firestore = initFirestore({\n *  credential: cert({\n *    projectId: process.env.FIREBASE_PROJECT_ID,\n *    clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n *    privateKey: process.env.FIREBASE_PRIVATE_KEY,\n *  })\n * })\n * ```\n */ function initFirestore(options = {}) {\n    const apps = (0,firebase_admin_app__WEBPACK_IMPORTED_MODULE_0__.getApps)();\n    const app = options.name ? apps.find((a)=>a.name === options.name) : apps[0];\n    if (app) return (0,firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__.getFirestore)(app);\n    return (0,firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__.initializeFirestore)((0,firebase_admin_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(options, options.name));\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGF1dGgrZmlyZWJhc2UtYWRhcHRlckAxLjAuMF9maXJlYmFzZS1hZG1pbkAxMS4xMC4xL25vZGVfbW9kdWxlcy9AYXV0aC9maXJlYmFzZS1hZGFwdGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUMyRDtBQUN3QztBQUNwRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNFQyxHQUNNLFNBQVNNLGlCQUFpQkMsTUFBTTtJQUNuQyxNQUFNLEVBQUVDLEVBQUUsRUFBRUMsaUJBQWlCLFNBQVMsRUFBRSxHQUFHRixrQkFBa0JMLCtEQUFTQSxHQUNoRTtRQUFFTSxJQUFJRDtJQUFPLElBQ2I7UUFBRSxHQUFHQSxNQUFNO1FBQUVDLElBQUlELFFBQVFHLGFBQWFDLGNBQWNKO0lBQVE7SUFDbEUsTUFBTUssa0JBQWtCSCxtQkFBbUI7SUFDM0MsTUFBTUksSUFBSUMsbUJBQW1CTixJQUFJSTtJQUNqQyxNQUFNRyxTQUFTQyxpQkFBaUJKO0lBQ2hDLE9BQU87UUFDSCxNQUFNSyxZQUFXQyxRQUFRO1lBQ3JCLE1BQU0sRUFBRUMsSUFBSUMsTUFBTSxFQUFFLEdBQUcsTUFBTVAsRUFBRVEsS0FBSyxDQUFDQyxHQUFHLENBQUNKO1lBQ3pDLE1BQU1LLE9BQU8sTUFBTUMsT0FBT1gsRUFBRVEsS0FBSyxDQUFDSSxHQUFHLENBQUNMO1lBQ3RDLElBQUksQ0FBQ0csTUFDRCxNQUFNLElBQUlHLE1BQU07WUFDcEIsT0FBT0g7UUFDWDtRQUNBLE1BQU1JLFNBQVFSLEVBQUU7WUFDWixPQUFPLE1BQU1LLE9BQU9YLEVBQUVRLEtBQUssQ0FBQ0ksR0FBRyxDQUFDTjtRQUNwQztRQUNBLE1BQU1TLGdCQUFlQyxLQUFLO1lBQ3RCLE9BQU8sTUFBTUMsVUFBVWpCLEVBQUVRLEtBQUss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O0FBQ0EsY0FBYyxHQUNQLFNBQVN6QyxtQkFBbUJOLEVBQUUsRUFBRUksa0JBQWtCLEtBQUs7SUFDMUQsT0FBTztRQUNIUyxPQUFPYixHQUNGOEYsVUFBVSxDQUFDLFNBQ1hDLGFBQWEsQ0FBQ2xCLGFBQWE7WUFBRXpFO1FBQWdCO1FBQ2xEbUMsVUFBVXZDLEdBQ0w4RixVQUFVLENBQUMsWUFDWEMsYUFBYSxDQUFDbEIsYUFBYTtZQUFFekU7UUFBZ0I7UUFDbER3QixVQUFVNUIsR0FDTDhGLFVBQVUsQ0FBQyxZQUNYQyxhQUFhLENBQUNsQixhQUFhO1lBQUV6RTtRQUFnQjtRQUNsRDRELHFCQUFxQmhFLEdBQ2hCOEYsVUFBVSxDQUFDMUYsa0JBQWtCLHdCQUF3QixzQkFDckQyRixhQUFhLENBQUNsQixhQUFhO1lBQUV6RTtZQUFpQm9GLFdBQVc7UUFBSztJQUN2RTtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ00sU0FBU3JGLGNBQWMyRSxVQUFVLENBQUMsQ0FBQztJQUN0QyxNQUFNa0IsT0FBT3hHLDJEQUFPQTtJQUNwQixNQUFNeUcsTUFBTW5CLFFBQVFvQixJQUFJLEdBQUdGLEtBQUtHLElBQUksQ0FBQyxDQUFDQyxJQUFNQSxFQUFFRixJQUFJLEtBQUtwQixRQUFRb0IsSUFBSSxJQUFJRixJQUFJLENBQUMsRUFBRTtJQUM5RSxJQUFJQyxLQUNBLE9BQU90RyxzRUFBWUEsQ0FBQ3NHO0lBQ3hCLE9BQU9yRyw2RUFBbUJBLENBQUNILGlFQUFhQSxDQUFDcUYsU0FBU0EsUUFBUW9CLElBQUk7QUFDbEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvLnBucG0vQGF1dGgrZmlyZWJhc2UtYWRhcHRlckAxLjAuMF9maXJlYmFzZS1hZG1pbkAxMS4xMC4xL25vZGVfbW9kdWxlcy9AYXV0aC9maXJlYmFzZS1hZGFwdGVyL2luZGV4LmpzPzNhY2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiA8ZGl2IHN0eWxlPXt7ZGlzcGxheTogXCJmbGV4XCIsIGp1c3RpZnlDb250ZW50OiBcInNwYWNlLWJldHdlZW5cIiwgYWxpZ25JdGVtczogXCJjZW50ZXJcIiwgcGFkZGluZzogMTZ9fT5cbiAqIDxzcGFuPlxuICogIE9mZmljaWFsIDxiPkZpcmViYXNlPC9iPiBhZGFwdGVyIGZvciBBdXRoLmpzIC8gTmV4dEF1dGguanMsXG4gKiAgdXNpbmcgdGhlIDxhIGhyZWY9XCJodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9hZG1pbi9zZXR1cFwiPkZpcmViYXNlIEFkbWluIFNESzwvYT5cbiAqICAmbmJzcDthbmQgPGEgaHJlZj1cImh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2ZpcmVzdG9yZVwiPkZpcmVzdG9yZTwvYT4uPC9zcGFuPlxuICogPGEgaHJlZj1cImh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9cIj5cbiAqICAgPGltZyBzdHlsZT17e2Rpc3BsYXk6IFwiYmxvY2tcIn19IHNyYz1cImh0dHBzOi8vYXV0aGpzLmRldi9pbWcvYWRhcHRlcnMvZmlyZWJhc2Uuc3ZnXCIgaGVpZ2h0PVwiNDhcIiB3aWR0aD1cIjQ4XCIvPlxuICogPC9hPlxuICogPC9kaXY+XG4gKlxuICogIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogYGBgYmFzaCBucG0yeWFybjJwbnBtXG4gKiBucG0gaW5zdGFsbCBAYXV0aC9maXJlYmFzZS1hZGFwdGVyIGZpcmViYXNlLWFkbWluXG4gKiBgYGBcbiAqXG4gKiBAbW9kdWxlIEBhdXRoL2ZpcmViYXNlLWFkYXB0ZXJcbiAqL1xuaW1wb3J0IHsgZ2V0QXBwcywgaW5pdGlhbGl6ZUFwcCB9IGZyb20gXCJmaXJlYmFzZS1hZG1pbi9hcHBcIjtcbmltcG9ydCB7IEZpcmVzdG9yZSwgZ2V0RmlyZXN0b3JlLCBpbml0aWFsaXplRmlyZXN0b3JlLCBUaW1lc3RhbXAsIH0gZnJvbSBcImZpcmViYXNlLWFkbWluL2ZpcmVzdG9yZVwiO1xuLyoqXG4gKiAjIyBTZXR1cFxuICpcbiAqIEZpcnN0LCBjcmVhdGUgYSBGaXJlYmFzZSBwcm9qZWN0IGFuZCBnZW5lcmF0ZSBhIHNlcnZpY2UgYWNjb3VudCBrZXkuIFZpc2l0OiBgaHR0cHM6Ly9jb25zb2xlLmZpcmViYXNlLmdvb2dsZS5jb20vdS8wL3Byb2plY3Qve3Byb2plY3QtaWR9L3NldHRpbmdzL3NlcnZpY2VhY2NvdW50cy9hZG1pbnNka2AgKHJlcGxhY2UgYHtwcm9qZWN0LWlkfWAgd2l0aCB5b3VyIHByb2plY3QncyBpZClcbiAqXG4gKiBOb3cgeW91IGhhdmUgYSBmZXcgb3B0aW9ucyB0byBhdXRoZW50aWNhdGUgd2l0aCB0aGUgRmlyZWJhc2UgQWRtaW4gU0RLIGluIHlvdXIgYXBwOlxuICpcbiAqICMjIyBFbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAqICAtIERvd25sb2FkIHRoZSBzZXJ2aWNlIGFjY291bnQga2V5IGFuZCBzYXZlIGl0IGluIHlvdXIgcHJvamVjdC4gKE1ha2Ugc3VyZSB0byBhZGQgdGhlIGZpbGUgdG8geW91ciBgLmdpdGlnbm9yZWAhKVxuICogIC0gQWRkIFtgR09PR0xFX0FQUExJQ0FUSU9OX0NSRURFTlRJQUxTYF0oaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2RvY3MvYXV0aGVudGljYXRpb24vYXBwbGljYXRpb24tZGVmYXVsdC1jcmVkZW50aWFscyNHQUMpIHRvIHlvdXIgZW52aXJvbm1lbnQgdmFyaWFibGVzIGFuZCBwb2ludCBpdCB0byB0aGUgc2VydmljZSBhY2NvdW50IGtleSBmaWxlLlxuICogIC0gVGhlIGFkYXB0ZXIgd2lsbCBhdXRvbWF0aWNhbGx5IHBpY2sgdXAgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIGFuZCB1c2UgaXQgdG8gYXV0aGVudGljYXRlIHdpdGggdGhlIEZpcmViYXNlIEFkbWluIFNESy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdGl0bGU9XCJwYWdlcy9hcGkvYXV0aC9bLi4ubmV4dGF1dGhdLnRzXCJcbiAqIGltcG9ydCBOZXh0QXV0aCBmcm9tIFwibmV4dC1hdXRoXCJcbiAqIGltcG9ydCB7IEZpcmVzdG9yZUFkYXB0ZXIgfSBmcm9tIFwiQGF1dGgvZmlyZWJhc2UtYWRhcHRlclwiXG4gKlxuICogZXhwb3J0IGRlZmF1bHQgTmV4dEF1dGgoe1xuICogICBhZGFwdGVyOiBGaXJlc3RvcmVBZGFwdGVyKCksXG4gKiAgIC8vIC4uLlxuICogfSlcbiAqIGBgYFxuICpcbiAqICMjIyBTZXJ2aWNlIGFjY291bnQgdmFsdWVzXG4gKlxuICogLSBEb3dubG9hZCB0aGUgc2VydmljZSBhY2NvdW50IGtleSB0byBhIHRlbXBvcmFyeSBsb2NhdGlvbi4gKE1ha2Ugc3VyZSB0byBub3QgY29tbWl0IHRoaXMgZmlsZSB0byB5b3VyIHJlcG9zaXRvcnkhKVxuICogLSBBZGQgdGhlIGZvbGxvd2luZyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8geW91ciBwcm9qZWN0OiBgRklSRUJBU0VfUFJPSkVDVF9JRGAsIGBGSVJFQkFTRV9DTElFTlRfRU1BSUxgLCBgRklSRUJBU0VfUFJJVkFURV9LRVlgLlxuICogLSBQYXNzIHRoZSBjb25maWcgdG8gdGhlIGFkYXB0ZXIsIHVzaW5nIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXMgc2hvd24gaW4gdGhlIGV4YW1wbGUgYmVsb3cuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHRpdGxlPVwicGFnZXMvYXBpL2F1dGgvWy4uLm5leHRhdXRoXS50c1wiXG4gKiBpbXBvcnQgTmV4dEF1dGggZnJvbSBcIm5leHQtYXV0aFwiXG4gKiBpbXBvcnQgeyBGaXJlc3RvcmVBZGFwdGVyIH0gZnJvbSBcIkBhdXRoL2ZpcmViYXNlLWFkYXB0ZXJcIlxuICogaW1wb3J0IHsgY2VydCB9IGZyb20gXCJmaXJlYmFzZS1hZG1pbi9hcHBcIlxuICpcbiAqIGV4cG9ydCBkZWZhdWx0IE5leHRBdXRoKHtcbiAqICBhZGFwdGVyOiBGaXJlc3RvcmVBZGFwdGVyKHtcbiAqICAgIGNyZWRlbnRpYWw6IGNlcnQoe1xuICogICAgICBwcm9qZWN0SWQ6IHByb2Nlc3MuZW52LkZJUkVCQVNFX1BST0pFQ1RfSUQsXG4gKiAgICAgIGNsaWVudEVtYWlsOiBwcm9jZXNzLmVudi5GSVJFQkFTRV9DTElFTlRfRU1BSUwsXG4gKiAgICAgIHByaXZhdGVLZXk6IHByb2Nlc3MuZW52LkZJUkVCQVNFX1BSSVZBVEVfS0VZLFxuICogICAgfSlcbiAqICB9KVxuICogIC8vIC4uLlxuICogfSlcbiAqIGBgYFxuICpcbiAqICMjIyBVc2luZyBhbiBleGlzdGluZyBGaXJlc3RvcmUgaW5zdGFuY2VcbiAqXG4gKiBJZiB5b3UgYWxyZWFkeSBoYXZlIGEgRmlyZXN0b3JlIGluc3RhbmNlLCB5b3UgY2FuIHBhc3MgdGhhdCB0byB0aGUgYWRhcHRlciBkaXJlY3RseSBpbnN0ZWFkLlxuICpcbiAqIDo6Om5vdGVcbiAqIFdoZW4gcGFzc2luZyBhbiBpbnN0YW5jZSBhbmQgaW4gYSBzZXJ2ZXJsZXNzIGVudmlyb25tZW50LCByZW1lbWJlciB0byBoYW5kbGUgZHVwbGljYXRlIGFwcCBpbml0aWFsaXphdGlvbi5cbiAqIDo6OlxuICpcbiAqIDo6OnRpcFxuICogWW91IGNhbiB1c2UgdGhlIHtAbGluayBpbml0RmlyZXN0b3JlfSB1dGlsaXR5IHRvIGluaXRpYWxpemUgdGhlIGFwcCBhbmQgZ2V0IGFuIGluc3RhbmNlIHNhZmVseS5cbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0aXRsZT1cInBhZ2VzL2FwaS9hdXRoL1suLi5uZXh0YXV0aF0udHNcIlxuICogaW1wb3J0IE5leHRBdXRoIGZyb20gXCJuZXh0LWF1dGhcIlxuICogaW1wb3J0IHsgRmlyZXN0b3JlQWRhcHRlciB9IGZyb20gXCJAYXV0aC9maXJlYmFzZS1hZGFwdGVyXCJcbiAqIGltcG9ydCB7IGZpcmVzdG9yZSB9IGZyb20gXCJsaWIvZmlyZXN0b3JlXCJcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBOZXh0QXV0aCh7XG4gKiAgYWRhcHRlcjogRmlyZXN0b3JlQWRhcHRlcihmaXJlc3RvcmUpLFxuICogIC8vIC4uLlxuICogfSlcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gRmlyZXN0b3JlQWRhcHRlcihjb25maWcpIHtcbiAgICBjb25zdCB7IGRiLCBuYW1pbmdTdHJhdGVneSA9IFwiZGVmYXVsdFwiIH0gPSBjb25maWcgaW5zdGFuY2VvZiBGaXJlc3RvcmVcbiAgICAgICAgPyB7IGRiOiBjb25maWcgfVxuICAgICAgICA6IHsgLi4uY29uZmlnLCBkYjogY29uZmlnPy5maXJlc3RvcmUgPz8gaW5pdEZpcmVzdG9yZShjb25maWcpIH07XG4gICAgY29uc3QgcHJlZmVyU25ha2VDYXNlID0gbmFtaW5nU3RyYXRlZ3kgPT09IFwic25ha2VfY2FzZVwiO1xuICAgIGNvbnN0IEMgPSBjb2xsZWN0aW9uc0ZhY3RvcnkoZGIsIHByZWZlclNuYWtlQ2FzZSk7XG4gICAgY29uc3QgbWFwcGVyID0gbWFwRmllbGRzRmFjdG9yeShwcmVmZXJTbmFrZUNhc2UpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFzeW5jIGNyZWF0ZVVzZXIodXNlckluaXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQ6IHVzZXJJZCB9ID0gYXdhaXQgQy51c2Vycy5hZGQodXNlckluaXQpO1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGdldERvYyhDLnVzZXJzLmRvYyh1c2VySWQpKTtcbiAgICAgICAgICAgIGlmICghdXNlcilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbY3JlYXRlVXNlcl0gRmFpbGVkIHRvIGZldGNoIGNyZWF0ZWQgdXNlclwiKTtcbiAgICAgICAgICAgIHJldHVybiB1c2VyO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRVc2VyKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZ2V0RG9jKEMudXNlcnMuZG9jKGlkKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGdldFVzZXJCeUVtYWlsKGVtYWlsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZ2V0T25lRG9jKEMudXNlcnMud2hlcmUoXCJlbWFpbFwiLCBcIj09XCIsIGVtYWlsKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGdldFVzZXJCeUFjY291bnQoeyBwcm92aWRlciwgcHJvdmlkZXJBY2NvdW50SWQgfSkge1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IGdldE9uZURvYyhDLmFjY291bnRzXG4gICAgICAgICAgICAgICAgLndoZXJlKFwicHJvdmlkZXJcIiwgXCI9PVwiLCBwcm92aWRlcilcbiAgICAgICAgICAgICAgICAud2hlcmUobWFwcGVyLnRvRGIoXCJwcm92aWRlckFjY291bnRJZFwiKSwgXCI9PVwiLCBwcm92aWRlckFjY291bnRJZCkpO1xuICAgICAgICAgICAgaWYgKCFhY2NvdW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGdldERvYyhDLnVzZXJzLmRvYyhhY2NvdW50LnVzZXJJZCkpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyB1cGRhdGVVc2VyKHBhcnRpYWxVc2VyKSB7XG4gICAgICAgICAgICBpZiAoIXBhcnRpYWxVc2VyLmlkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlt1cGRhdGVVc2VyXSBNaXNzaW5nIGlkXCIpO1xuICAgICAgICAgICAgY29uc3QgdXNlclJlZiA9IEMudXNlcnMuZG9jKHBhcnRpYWxVc2VyLmlkKTtcbiAgICAgICAgICAgIGF3YWl0IHVzZXJSZWYuc2V0KHBhcnRpYWxVc2VyLCB7IG1lcmdlOiB0cnVlIH0pO1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGdldERvYyh1c2VyUmVmKTtcbiAgICAgICAgICAgIGlmICghdXNlcilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbdXBkYXRlVXNlcl0gRmFpbGVkIHRvIGZldGNoIHVwZGF0ZWQgdXNlclwiKTtcbiAgICAgICAgICAgIHJldHVybiB1c2VyO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBkZWxldGVVc2VyKHVzZXJJZCkge1xuICAgICAgICAgICAgYXdhaXQgZGIucnVuVHJhbnNhY3Rpb24oYXN5bmMgKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBDLmFjY291bnRzXG4gICAgICAgICAgICAgICAgICAgIC53aGVyZShtYXBwZXIudG9EYihcInVzZXJJZFwiKSwgXCI9PVwiLCB1c2VySWQpXG4gICAgICAgICAgICAgICAgICAgIC5nZXQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9ucyA9IGF3YWl0IEMuc2Vzc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgLndoZXJlKG1hcHBlci50b0RiKFwidXNlcklkXCIpLCBcIj09XCIsIHVzZXJJZClcbiAgICAgICAgICAgICAgICAgICAgLmdldCgpO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmRlbGV0ZShDLnVzZXJzLmRvYyh1c2VySWQpKTtcbiAgICAgICAgICAgICAgICBhY2NvdW50cy5mb3JFYWNoKChhY2NvdW50KSA9PiB0cmFuc2FjdGlvbi5kZWxldGUoYWNjb3VudC5yZWYpKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9ucy5mb3JFYWNoKChzZXNzaW9uKSA9PiB0cmFuc2FjdGlvbi5kZWxldGUoc2Vzc2lvbi5yZWYpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBsaW5rQWNjb3VudChhY2NvdW50SW5pdCkge1xuICAgICAgICAgICAgY29uc3QgcmVmID0gYXdhaXQgQy5hY2NvdW50cy5hZGQoYWNjb3VudEluaXQpO1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IHJlZi5nZXQoKS50aGVuKChkb2MpID0+IGRvYy5kYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIGFjY291bnQgPz8gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgdW5saW5rQWNjb3VudCh7IHByb3ZpZGVyLCBwcm92aWRlckFjY291bnRJZCB9KSB7XG4gICAgICAgICAgICBhd2FpdCBkZWxldGVEb2NzKEMuYWNjb3VudHNcbiAgICAgICAgICAgICAgICAud2hlcmUoXCJwcm92aWRlclwiLCBcIj09XCIsIHByb3ZpZGVyKVxuICAgICAgICAgICAgICAgIC53aGVyZShtYXBwZXIudG9EYihcInByb3ZpZGVyQWNjb3VudElkXCIpLCBcIj09XCIsIHByb3ZpZGVyQWNjb3VudElkKVxuICAgICAgICAgICAgICAgIC5saW1pdCgxKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGNyZWF0ZVNlc3Npb24oc2Vzc2lvbkluaXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IGF3YWl0IEMuc2Vzc2lvbnMuYWRkKHNlc3Npb25Jbml0KTtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCByZWYuZ2V0KCkudGhlbigoZG9jKSA9PiBkb2MuZGF0YSgpKTtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uID8/IG51bGw7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbY3JlYXRlU2Vzc2lvbl0gRmFpbGVkIHRvIGZldGNoIGNyZWF0ZWQgc2Vzc2lvblwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0U2Vzc2lvbkFuZFVzZXIoc2Vzc2lvblRva2VuKSB7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgZ2V0T25lRG9jKEMuc2Vzc2lvbnMud2hlcmUobWFwcGVyLnRvRGIoXCJzZXNzaW9uVG9rZW5cIiksIFwiPT1cIiwgc2Vzc2lvblRva2VuKSk7XG4gICAgICAgICAgICBpZiAoIXNlc3Npb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgZ2V0RG9jKEMudXNlcnMuZG9jKHNlc3Npb24udXNlcklkKSk7XG4gICAgICAgICAgICBpZiAoIXVzZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4geyBzZXNzaW9uLCB1c2VyIH07XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHVwZGF0ZVNlc3Npb24ocGFydGlhbFNlc3Npb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IGF3YWl0IGRiLnJ1blRyYW5zYWN0aW9uKGFzeW5jICh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25TbmFwc2hvdCA9IChhd2FpdCB0cmFuc2FjdGlvbi5nZXQoQy5zZXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICAud2hlcmUobWFwcGVyLnRvRGIoXCJzZXNzaW9uVG9rZW5cIiksIFwiPT1cIiwgcGFydGlhbFNlc3Npb24uc2Vzc2lvblRva2VuKVxuICAgICAgICAgICAgICAgICAgICAubGltaXQoMSkpKS5kb2NzWzBdO1xuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvblNuYXBzaG90Py5leGlzdHMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLnNldChzZXNzaW9uU25hcHNob3QucmVmLCBwYXJ0aWFsU2Vzc2lvbiwgeyBtZXJnZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvblNuYXBzaG90LmlkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXNlc3Npb25JZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBnZXREb2MoQy5zZXNzaW9ucy5kb2Moc2Vzc2lvbklkKSk7XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlt1cGRhdGVTZXNzaW9uXSBGYWlsZWQgdG8gZmV0Y2ggdXBkYXRlZCBzZXNzaW9uXCIpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBkZWxldGVTZXNzaW9uKHNlc3Npb25Ub2tlbikge1xuICAgICAgICAgICAgYXdhaXQgZGVsZXRlRG9jcyhDLnNlc3Npb25zXG4gICAgICAgICAgICAgICAgLndoZXJlKG1hcHBlci50b0RiKFwic2Vzc2lvblRva2VuXCIpLCBcIj09XCIsIHNlc3Npb25Ub2tlbilcbiAgICAgICAgICAgICAgICAubGltaXQoMSkpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBjcmVhdGVWZXJpZmljYXRpb25Ub2tlbih2ZXJpZmljYXRpb25Ub2tlbikge1xuICAgICAgICAgICAgYXdhaXQgQy52ZXJpZmljYXRpb25fdG9rZW5zLmFkZCh2ZXJpZmljYXRpb25Ub2tlbik7XG4gICAgICAgICAgICByZXR1cm4gdmVyaWZpY2F0aW9uVG9rZW47XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHVzZVZlcmlmaWNhdGlvblRva2VuKHsgaWRlbnRpZmllciwgdG9rZW4gfSkge1xuICAgICAgICAgICAgY29uc3QgdmVyaWZpY2F0aW9uVG9rZW5TbmFwc2hvdCA9IChhd2FpdCBDLnZlcmlmaWNhdGlvbl90b2tlbnNcbiAgICAgICAgICAgICAgICAud2hlcmUoXCJpZGVudGlmaWVyXCIsIFwiPT1cIiwgaWRlbnRpZmllcilcbiAgICAgICAgICAgICAgICAud2hlcmUoXCJ0b2tlblwiLCBcIj09XCIsIHRva2VuKVxuICAgICAgICAgICAgICAgIC5saW1pdCgxKVxuICAgICAgICAgICAgICAgIC5nZXQoKSkuZG9jc1swXTtcbiAgICAgICAgICAgIGlmICghdmVyaWZpY2F0aW9uVG9rZW5TbmFwc2hvdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB2ZXJpZmljYXRpb25Ub2tlblNuYXBzaG90LmRhdGEoKTtcbiAgICAgICAgICAgIGF3YWl0IHZlcmlmaWNhdGlvblRva2VuU25hcHNob3QucmVmLmRlbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIGZvciBjb25zaXN0ZW5jeSwgc3RvcmUgYWxsIGZpZWxkcyBhcyBzbmFrZV9jYXNlIGluIHRoZSBkYXRhYmFzZVxuY29uc3QgTUFQX1RPX0ZJUkVTVE9SRSA9IHtcbiAgICB1c2VySWQ6IFwidXNlcl9pZFwiLFxuICAgIHNlc3Npb25Ub2tlbjogXCJzZXNzaW9uX3Rva2VuXCIsXG4gICAgcHJvdmlkZXJBY2NvdW50SWQ6IFwicHJvdmlkZXJfYWNjb3VudF9pZFwiLFxuICAgIGVtYWlsVmVyaWZpZWQ6IFwiZW1haWxfdmVyaWZpZWRcIixcbn07XG5jb25zdCBNQVBfRlJPTV9GSVJFU1RPUkUgPSB7fTtcbmZvciAoY29uc3Qga2V5IGluIE1BUF9UT19GSVJFU1RPUkUpIHtcbiAgICBNQVBfRlJPTV9GSVJFU1RPUkVbTUFQX1RPX0ZJUkVTVE9SRVtrZXldXSA9IGtleTtcbn1cbmNvbnN0IGlkZW50aXR5ID0gKHgpID0+IHg7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gbWFwRmllbGRzRmFjdG9yeShwcmVmZXJTbmFrZUNhc2UpIHtcbiAgICBpZiAocHJlZmVyU25ha2VDYXNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b0RiOiAoZmllbGQpID0+IE1BUF9UT19GSVJFU1RPUkVbZmllbGRdID8/IGZpZWxkLFxuICAgICAgICAgICAgZnJvbURiOiAoZmllbGQpID0+IE1BUF9GUk9NX0ZJUkVTVE9SRVtmaWVsZF0gPz8gZmllbGQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IHRvRGI6IGlkZW50aXR5LCBmcm9tRGI6IGlkZW50aXR5IH07XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBnZXRDb252ZXJ0ZXIob3B0aW9ucykge1xuICAgIGNvbnN0IG1hcHBlciA9IG1hcEZpZWxkc0ZhY3Rvcnkob3B0aW9ucz8ucHJlZmVyU25ha2VDYXNlID8/IGZhbHNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b0ZpcmVzdG9yZShvYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcImlkXCIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRbbWFwcGVyLnRvRGIoa2V5KV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmlyZWJhc2VBZGFwdGVyOiB2YWx1ZSBmb3Iga2V5IFwiJHtrZXl9XCIgaXMgdW5kZWZpbmVkYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9LFxuICAgICAgICBmcm9tRmlyZXN0b3JlKHNuYXBzaG90KSB7XG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IHNuYXBzaG90LmRhdGEoKTsgLy8gd2UgY2FuIGd1YXJhbnRlZSBpdCBleGlzdHNcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zPy5leGNsdWRlSWQpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuaWQgPSBzbmFwc2hvdC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZG9jdW1lbnRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBUaW1lc3RhbXApXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9EYXRlKCk7XG4gICAgICAgICAgICAgICAgb2JqZWN0W21hcHBlci5mcm9tRGIoa2V5KV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRPbmVEb2MocXVlcnlTbmFwc2hvdCkge1xuICAgIGNvbnN0IHF1ZXJ5U25hcCA9IGF3YWl0IHF1ZXJ5U25hcHNob3QubGltaXQoMSkuZ2V0KCk7XG4gICAgcmV0dXJuIHF1ZXJ5U25hcC5kb2NzWzBdPy5kYXRhKCkgPz8gbnVsbDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZURvY3MocXVlcnlTbmFwc2hvdCkge1xuICAgIGNvbnN0IHF1ZXJ5U25hcCA9IGF3YWl0IHF1ZXJ5U25hcHNob3QuZ2V0KCk7XG4gICAgZm9yIChjb25zdCBkb2Mgb2YgcXVlcnlTbmFwLmRvY3MpIHtcbiAgICAgICAgYXdhaXQgZG9jLnJlZi5kZWxldGUoKTtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RG9jKGRvY1JlZikge1xuICAgIGNvbnN0IGRvY1NuYXAgPSBhd2FpdCBkb2NSZWYuZ2V0KCk7XG4gICAgcmV0dXJuIGRvY1NuYXAuZGF0YSgpID8/IG51bGw7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gY29sbGVjdGlvbnNGYWN0b3J5KGRiLCBwcmVmZXJTbmFrZUNhc2UgPSBmYWxzZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHVzZXJzOiBkYlxuICAgICAgICAgICAgLmNvbGxlY3Rpb24oXCJ1c2Vyc1wiKVxuICAgICAgICAgICAgLndpdGhDb252ZXJ0ZXIoZ2V0Q29udmVydGVyKHsgcHJlZmVyU25ha2VDYXNlIH0pKSxcbiAgICAgICAgc2Vzc2lvbnM6IGRiXG4gICAgICAgICAgICAuY29sbGVjdGlvbihcInNlc3Npb25zXCIpXG4gICAgICAgICAgICAud2l0aENvbnZlcnRlcihnZXRDb252ZXJ0ZXIoeyBwcmVmZXJTbmFrZUNhc2UgfSkpLFxuICAgICAgICBhY2NvdW50czogZGJcbiAgICAgICAgICAgIC5jb2xsZWN0aW9uKFwiYWNjb3VudHNcIilcbiAgICAgICAgICAgIC53aXRoQ29udmVydGVyKGdldENvbnZlcnRlcih7IHByZWZlclNuYWtlQ2FzZSB9KSksXG4gICAgICAgIHZlcmlmaWNhdGlvbl90b2tlbnM6IGRiXG4gICAgICAgICAgICAuY29sbGVjdGlvbihwcmVmZXJTbmFrZUNhc2UgPyBcInZlcmlmaWNhdGlvbl90b2tlbnNcIiA6IFwidmVyaWZpY2F0aW9uVG9rZW5zXCIpXG4gICAgICAgICAgICAud2l0aENvbnZlcnRlcihnZXRDb252ZXJ0ZXIoeyBwcmVmZXJTbmFrZUNhc2UsIGV4Y2x1ZGVJZDogdHJ1ZSB9KSksXG4gICAgfTtcbn1cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0aGF0IGhlbHBzIG1ha2luZyBzdXJlIHRoYXQgdGhlcmUgaXMgbm8gZHVwbGljYXRlIGFwcCBpbml0aWFsaXphdGlvbiBpc3N1ZXMgaW4gc2VydmVybGVzcyBlbnZpcm9ubWVudHMuXG4gKiBJZiBubyBwYXJhbWV0ZXIgaXMgcGFzc2VkLCBpdCB3aWxsIHVzZSB0aGUgYEdPT0dMRV9BUFBMSUNBVElPTl9DUkVERU5USUFMU2AgZW52aXJvbm1lbnQgdmFyaWFibGUgdG8gaW5pdGlhbGl6ZSBhIEZpcmVzdG9yZSBpbnN0YW5jZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdGl0bGU9XCJsaWIvZmlyZXN0b3JlLnRzXCJcbiAqIGltcG9ydCB7IGluaXRGaXJlc3RvcmUgfSBmcm9tIFwiQGF1dGgvZmlyZWJhc2UtYWRhcHRlclwiXG4gKiBpbXBvcnQgeyBjZXJ0IH0gZnJvbSBcImZpcmViYXNlLWFkbWluL2FwcFwiXG4gKlxuICogZXhwb3J0IGNvbnN0IGZpcmVzdG9yZSA9IGluaXRGaXJlc3RvcmUoe1xuICogIGNyZWRlbnRpYWw6IGNlcnQoe1xuICogICAgcHJvamVjdElkOiBwcm9jZXNzLmVudi5GSVJFQkFTRV9QUk9KRUNUX0lELFxuICogICAgY2xpZW50RW1haWw6IHByb2Nlc3MuZW52LkZJUkVCQVNFX0NMSUVOVF9FTUFJTCxcbiAqICAgIHByaXZhdGVLZXk6IHByb2Nlc3MuZW52LkZJUkVCQVNFX1BSSVZBVEVfS0VZLFxuICogIH0pXG4gKiB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0RmlyZXN0b3JlKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGFwcHMgPSBnZXRBcHBzKCk7XG4gICAgY29uc3QgYXBwID0gb3B0aW9ucy5uYW1lID8gYXBwcy5maW5kKChhKSA9PiBhLm5hbWUgPT09IG9wdGlvbnMubmFtZSkgOiBhcHBzWzBdO1xuICAgIGlmIChhcHApXG4gICAgICAgIHJldHVybiBnZXRGaXJlc3RvcmUoYXBwKTtcbiAgICByZXR1cm4gaW5pdGlhbGl6ZUZpcmVzdG9yZShpbml0aWFsaXplQXBwKG9wdGlvbnMsIG9wdGlvbnMubmFtZSkpO1xufVxuIl0sIm5hbWVzIjpbImdldEFwcHMiLCJpbml0aWFsaXplQXBwIiwiRmlyZXN0b3JlIiwiZ2V0RmlyZXN0b3JlIiwiaW5pdGlhbGl6ZUZpcmVzdG9yZSIsIlRpbWVzdGFtcCIsIkZpcmVzdG9yZUFkYXB0ZXIiLCJjb25maWciLCJkYiIsIm5hbWluZ1N0cmF0ZWd5IiwiZmlyZXN0b3JlIiwiaW5pdEZpcmVzdG9yZSIsInByZWZlclNuYWtlQ2FzZSIsIkMiLCJjb2xsZWN0aW9uc0ZhY3RvcnkiLCJtYXBwZXIiLCJtYXBGaWVsZHNGYWN0b3J5IiwiY3JlYXRlVXNlciIsInVzZXJJbml0IiwiaWQiLCJ1c2VySWQiLCJ1c2VycyIsImFkZCIsInVzZXIiLCJnZXREb2MiLCJkb2MiLCJFcnJvciIsImdldFVzZXIiLCJnZXRVc2VyQnlFbWFpbCIsImVtYWlsIiwiZ2V0T25lRG9jIiwid2hlcmUiLCJnZXRVc2VyQnlBY2NvdW50IiwicHJvdmlkZXIiLCJwcm92aWRlckFjY291bnRJZCIsImFjY291bnQiLCJhY2NvdW50cyIsInRvRGIiLCJ1cGRhdGVVc2VyIiwicGFydGlhbFVzZXIiLCJ1c2VyUmVmIiwic2V0IiwibWVyZ2UiLCJkZWxldGVVc2VyIiwicnVuVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbiIsImdldCIsInNlc3Npb25zIiwiZGVsZXRlIiwiZm9yRWFjaCIsInJlZiIsInNlc3Npb24iLCJsaW5rQWNjb3VudCIsImFjY291bnRJbml0IiwidGhlbiIsImRhdGEiLCJ1bmxpbmtBY2NvdW50IiwiZGVsZXRlRG9jcyIsImxpbWl0IiwiY3JlYXRlU2Vzc2lvbiIsInNlc3Npb25Jbml0IiwiZ2V0U2Vzc2lvbkFuZFVzZXIiLCJzZXNzaW9uVG9rZW4iLCJ1cGRhdGVTZXNzaW9uIiwicGFydGlhbFNlc3Npb24iLCJzZXNzaW9uSWQiLCJzZXNzaW9uU25hcHNob3QiLCJkb2NzIiwiZXhpc3RzIiwiZGVsZXRlU2Vzc2lvbiIsImNyZWF0ZVZlcmlmaWNhdGlvblRva2VuIiwidmVyaWZpY2F0aW9uVG9rZW4iLCJ2ZXJpZmljYXRpb25fdG9rZW5zIiwidXNlVmVyaWZpY2F0aW9uVG9rZW4iLCJpZGVudGlmaWVyIiwidG9rZW4iLCJ2ZXJpZmljYXRpb25Ub2tlblNuYXBzaG90IiwiTUFQX1RPX0ZJUkVTVE9SRSIsImVtYWlsVmVyaWZpZWQiLCJNQVBfRlJPTV9GSVJFU1RPUkUiLCJrZXkiLCJpZGVudGl0eSIsIngiLCJmaWVsZCIsImZyb21EYiIsImdldENvbnZlcnRlciIsIm9wdGlvbnMiLCJ0b0ZpcmVzdG9yZSIsIm9iamVjdCIsImRvY3VtZW50IiwidmFsdWUiLCJ1bmRlZmluZWQiLCJjb25zb2xlIiwid2FybiIsImZyb21GaXJlc3RvcmUiLCJzbmFwc2hvdCIsImV4Y2x1ZGVJZCIsInRvRGF0ZSIsInF1ZXJ5U25hcHNob3QiLCJxdWVyeVNuYXAiLCJkb2NSZWYiLCJkb2NTbmFwIiwiY29sbGVjdGlvbiIsIndpdGhDb252ZXJ0ZXIiLCJhcHBzIiwiYXBwIiwibmFtZSIsImZpbmQiLCJhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@auth+firebase-adapter@1.0.0_firebase-admin@11.10.1/node_modules/@auth/firebase-adapter/index.js\n");

/***/ })

};
;